---
author: gavin
comments: true
date: 2013-08-02 21:37:02
layout: post
slug: c%e5%86%85%e7%bd%ae%e7%b1%bb%e5%9e%8b
title: C++内置类型
wordpress_id: 231
categories:
- C++
---

## C++变量名命名规则





C++变量命名必须遵循几种简单的命名规则：







  * 在名称中只能使用字母字符、数字和下划线（_）。


  * 名称的第一个字符不能是数字。


  * 区分大写字符和小写字符。


  * 不能将C++关键字用作名称。


  * 以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。注意：**违反这一点不会导致编译器错误，但会导致行为的不确定性。**


  * C++对名称的长度没有限制，名称中所有的字符都有意义。





## 基本数据类型





### 整型





C++中基本整型分别是`char`、`short`、`int`和`long`，还有新增的`bool`类型，前四种都分有符号类型和无符号类型。





#### char





`char`类型的长度通常是单个机器字节（byte），它保证能够表示目标计算机系统中的所有基本符号——所有的字母、数字、标点符号等。另外，`wchar_t`类型用于扩展字符集，比如汉字和日语。`wchar_t`也是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。这种类型与另一种整型（底层类型）的长度和符号属性相同。对底层类型的选择取决于实现，因此在一个系统中，它可能是`unsigned short`，而在另一个系统中，则可能是`int`。





#### short





`short`至少16位。





#### int





`int`至少与`short`一样长。自然长度，即计算机处理起来效率最高的长度。





#### long





`long`至少32位，且至少与int一样长。C99添加了两种新类型：`long long`和`unsigned long long`。两种类型至少是64位，且至少同`long`和`unsigned long`类型一样宽。  

要知道系统中整数的最大长度，可以使用`sizeof`操作符返回类型或变量的长度，单位为字节。另外，头文件`climits`中包含了关于整型限制的信息，例如`INT_MAX`为`int`类型的最大取值，`CHAR_BIT`为字节的位数等等。  

注意：**可以将负数赋给无符号整型变量**，其值是负数对该类型的取值个数求模后的值。





#### bool类型





`bool`变量的值可以是`true`或`false`。同时，C++也将非零值解释为`true`，将零解释为`false`。  

字面值`true`跟`false`都可以通过提升转换为`int`类型，`true`被转换为1，`false`被转换为0。另外，任何数字值或指针值都可以被隐式转换为`bool`值。任何非零值都被转换为`true`，而零被转换为`false`：




    
    <code>bool start = -100;    //start被赋值为true
    bool stop = 0;        //stop被赋值为false</code>





### 浮点数





浮点数能表示带小数部分的数字，它们提供的值范围也更大。比如，如果数字很大，无法表示为`long`类型，则可以使用浮点类型来表示。计算机将浮点数的值分为两部分存储，一部分表示值，另一部分用于对值进行放大或缩小。  

浮点数的书写方式有两种：







  * 标准小数点表示法，例如：`12.34`。


  * E表示法，例如：`3.45E6`。E表示法最适合于表示非常大和非常小的数。而且这种表示法可以确保数字以浮点数格式存储，即使没有小数点。





C++有三种浮点类型：`float`、`double`和`long double`。这些类型是按它们可以表示的有效数位和允许的指数最小范围来描述的。有效数位（significant figure）指数字中意义的位，有效位数不依赖于小数点的位置。例如，数字14000，有效位数为2，其余三位都是占位符。  

事实上，C和C++对于有效位数的具体要求是，`float`至少32位，`double`至少48位，且不少于`float`，`long double`至少和`double`一样多。这三种类型的有效位数可以一样多。不过，通常，`float`为32位，`double`为64位，`long double`为80、96或128位。另外，这三种类型的指数范围至少是-37到37。可以从头文件`cfloat`或`float.h`中找到系统的限制。  

与整数相比，浮点数有两大优势。首先，它们可以表示整数之间的值。其次，由于有缩放因子，它们可以表示的范围大得多。另一方面，浮点运算的速度比整数运算慢，至少在没有数学协处理器的计算机上如此，而且精度将降低。





### 类型转换





C++丰富的类型允许根据需求选择不同的类型，这也使计算机的操作更复杂。例如，将两个`short`值相加涉及到的硬件编译指令可能会与将两个`long`值相加不同。由于有11种整型和3种浮点类型，因此计算机需要处理大量不同的情况，尤其是对不同的类型进行运算时。为处理这种潜在的混乱，C++自动执行很多类型转换：







  * 将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换。这样做时，值将被转换为接收变量的类型。这种情况下，将一个值赋给取值范围更大的类型通常不会导致什么问题。但以下几种情况的转换将会产生一些问题：



    * 将较大的浮点类型转换为较小的浮点类型时，精度（有效位数）降低，值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的。


    * 将浮点类型转换为整型时，小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的。


    * 将较大的整型转换为较小的整型时，原来的值可能超出目标类型的取值范围，通常只复制右边的字节。




  * 表达式中包含不同的类型时，C++将对值进行转换。在这种情况下，C++将执行两种自动转换：



    * 一些类型在出现时便会自动转换：在计算表达式时，C++将`bool`、`char`、`unsigned char`、`signed char`和`short`值转换为`int`。这些转换被称为整型提升（integral promotion）。还有其它的一些整型提升：如果`short`比`int`短，则`unsigned short`类型将被转换为`int`；如果两种类型的长度相同，则`unsigned short`将被转换为`unsigned int`。同样，`wchar_t`被提升为下列类型中第一个宽度足够存储`wchar_t`取值范围的类型：`int`、`unsigned int`、`long`或`unsigned long`。


    * 有些类型在与其它类型同时出现在表达式中时将被转换，例如将`int`和`float`相加时。当计算涉及到两种类型时，较小的类型将被转换为较大的类型。编译器通过校验表来确定在算术表达式中执行的转换。下面是一个列表，编译器将依次查阅该列表：



      * 如果有一个操作数的类型是`long double`，则将另一个操作数转换为`long double`。


      * 否则，如果有一个操作数的类型是`double`，则将另一个操作数转换为`double`。


      * 否则，如果有一个操作数的类型是`float`，则将另一个操作数转换为float`。


      * 否则，说明操作数都是整型，因此执行整型提升。


      * 在这种情况下，如果有一个操作数的类型是`unsigned long`，则将另一个操作数转换为`unsigned long`。


      * 否则，如果有一个操作数是`long int`，而另一个操作数是`unsigned int`，则转换取决于两种类型的相对长度。如果`long`能够表示`unsigned int`的所有可能值，则将`unsigned int`转换为`long`。


      * 否则，将两个操作数都转换为`unsigned int`。


      * 否则，如果一个操作数是`long`，则将另一个操作数转换为`long`。


      * 否则，如果一个操作数是`unsigned int`，则将另一个操作数转换为`unsigned int`。


      * 如果编译器到达此处，则说明两个操作数都是`int`类型。






  * 将参数传递给函数时，C++将对值进行转换。在这种情况下，传递参数时的类型转换通常由C++函数原型控制。如果取消原型对参数传递的控制，C++将对`char`和`short`类型（`signed`和`unsigned`）应用整型提升。另外，为保持与C代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将`float`参数提升为`double`。


  * 强制类型转换：强制类型转换有两种格式：`(typename) value`和`typename (value)`。第一种方式来自C语言，第二种则是纯粹的C++风格。C++还引入了4种强制类型转换操作符：



    * `const_cast`，去掉`const`或`volatile`属性。`const_cast`不能在不同的类之间转换，它仅仅把它作用的表达式转换成常量。它可以使一个本来不是`const`类型的数据转换成`const`，或者把`const`属性去掉。


    * `static_cast`，静态类型转换。用于C++中内置基本数据类型之间的相互转换，如果涉及到类的话，`static_cast`只能在有相互联系的类型中进行有效的相互转换，不一定包含虚函数。


    * `dynamic_cast`，有条件转换，动态类型转换，运行时类型安全检查（转换失败时返回NULL）：



      * 其它三种都是编译时完成的，`dynamic_cast`是运行时处理的。


      * 不能用于内置的基本数据类型的强制转换。


      * 转换如果成功，返回的是指针或引用，否则返回NULL。


      * 使用`dynamic_cast`转换时，基类中一定要有虚函数，否则编译不通过。理由是：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中。


      * 在类层次间向上转换时，`dynamic_cast`和`static_cast`效果是一样的。在下行转换时，`dynamic_cast`具有类型检查的功能，比`static_cast`要更安全。




    * `reinterpret_cast`，仅仅重新解释类型，没有进行二进制的转换。







## 复合类型





在计算机科学中，复合类型是一种数据类型，它可以是原始类型和其它的复合类型所构成。构成一个复合类型的动作，又称作组合。





### 数组





数组能够存储多个同类型的值，每个值都存储在一个独立的数组元素之中，计算机在内存中依次存储数组的各个元素。可以单独访问数组元素，方法是使用下标或索引来对元素进行编号。  

数组之所以被称为复合类型，是因为它是使用其它类型来创建的。不能仅仅将某种东西声明为类型，它必须是特定类型的数组。





### 结构





结构是一种比数组更加灵活的数据类型，它可以存储多种类型的数据，从而将数据表示合并到一起。结构也是类的基石。  

结构是用户自定义的类型，结构声明定义了这种类型的数据属性。因为在声明时，使用了关键字`struct`，所以简称为结构，更精确的定义是**用户定义的数据结构**。  

在C++中，`struct`和`class`唯一的区别是默认的访问等级，`class`是私有的，`struct`是公有的。C++的`struct`是C `struct`的超集：几乎所有合法的C `struct`也是合法的C++ `struct`，并有着相同的语义。




    
    <code>struct onestruct{
        int int_val;
        float float_val;
    }</code>





### 共用体





共用体是一种数据类型，它能够存储不同的数据类型，但只能同时存储其中的一种类型。共用体的句法与结构相同，但含义不同。共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。





### 枚举





enum提供了另一种创建符号常量的方式，这种方式可以代替`const`。它还允许定义新类型，但必须按严格的限制进行。使用`enum`的句法与使用结构相似。




    
    <code>enum spectrum{red, orange, yellow}</code>





在默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依此类推。可以通过显式地指定整数值来覆盖默认值。枚举变量的一些属性：







  * 在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量。如果试图将一个非法值赋给枚举变量，则有些编译器将出现编译器错误，而另一些则发出警告。为获得最大限度的可移植性，应将非`enum`值赋给`enum`变量视为错误。


  * 对于枚举，只定义了赋值操作符。也就是说，没有为枚举定义算术运算符。不过有些实现并没有这种限制，这有可能导致违反类型限制。为获得最大限度的可移植性，应采纳较严格的限制。


  * 枚举量是整型，可被提升为`int`，但int类型不能自动转换为枚举类型。同样，有些实现并没有这种限制。当然，如果`int`值是有效的，则可以通过强制类型转换，将它赋给枚举变量。如果试图对一个不适当的值进行强制类型转换，则结果是不确定的，这意味着这样做不会出错，但不能依赖得到的结果。





枚举的取值范围：首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的值便是取值范围的上限。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0；否则，采用与寻找上限方式相同的办法，但加上负号。  

选择用多少空间存储枚举由编译器决定。对于取值范围较小的枚举，使用一个字节或更少的空间；而对于包含`long`类型值的枚举，则使用4个字节。





## 指针





指针是一个变量，它存储的是值的地址，而不是值本身。对变量应用地址操作符（&），就可以获得它的位置。指针名表示的是地址，`*`操作符被称为间接值或解除引用操作符，将其应用于指针，可以得到该地址处存储的值。  

在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤。  

**警告：一定要在对指针应用解除引用操作符（`*`）之前，将指针初始化为一个确定的、适当的地址。**





### 指针的空间分配





#### 基本数据类型





在程序编译或者运行时，系统会开辟一张表。每遇到一次声明语句（包括变量的声明、函数的声明和传入参数的声明等等）都会开辟一个内存空间，并在表中增加一行记录，记载一些对应信息。以32位操作系统为例：






   


      
声明

      
序号

      
变量名

      
内存地址

      
访问长度

      
值

   
   


      
int nP;

      
1

      
nP

      
2000

      
4B

      
0xCCCCCCCC

   
   


      
char myChar;

      
2

      
myChar

      
2002

      
1B

      
0xCC

   
   


      
int * myPointer;

      
3

      
myPointer

      
2003

      
4B

      
0xCCCCCCCC

   
   


      
char * myPointer2;

      
4

      
myPointer2

      
2005

      
4B

      
0xCCCCCCCC

   




#### 高级数据类型





以结构体为例，结构体是按顺序分配空间的，假设有下面的代码：




    
    <code>typedef struct st{
        double val;
        char c;
        struct st *next;
    } pst;
    
    int a[20];
    pst pT[10];</code>





在32位系统下，内存可能如下分配：






   


      
变量

      
2000

      
2001

      
2002

      
2003

      
2004

      
2005

      
2006

      
…

      
204C

      
204D

      
204E

      
204F

   
   


      
地址

      
a[0]

      

      

      

      
a[1]

      

      

      
…

      
a[19]

      

      

      

   





   


      
变量

      
2050

      
2051

      
…

      
2057

      
2058

      
2059

      
205A

      
205B

      
205C

      
205D

      
205E

      
205F

   
   


      
地址

      
pst.val

      

      
…

      

      
pst.c

      
pst.next

      

      

      

      
无效

      
无效

      
无效

   




之所以后三位无效，是涉及到了内存对齐的问题。编译器把结构体的大小规定为结构体成员中大小最大的那个类型的整数倍。





### new操作符





C语言中，可以用库函数`malloc()`来分配内存；在C++中也可以这样做，但是还有更好的办法——`new`操作符。这也涉及到一个重要的OOP技术——在程序运行时分配内存。  

`new`是C++程序设计语言中的一种语言结构，用于动态分配内存、并用构造函数初始化内存。如果`new`成功获得了足够内存，则初始化这块内存并返回其首地址。如果`new`不能成功获得内存，则调用`new_handler`函数。如果没有设置`new_handler`函数或者`new_handler`未能分配足够内存，则抛出`std::bad_alloc`异常。每个`new`获取的对象，必须用`delete`析构并释放内存，以免内存泄漏。





#### 语法





`new`的语法是：




    
    <code>p_var = new typename;</code>





通过new初始化对象，使用下述语法：




    
    <code>p_var = new type(initializer);</code>





`new`也可创建一个动态数组，称之为“array forms new”：




    
    <code>p_var = new type[size];</code>





**注意：**new创建的对象数组不能被显式初始化，数组所有元素被缺省初始化。如果数组基类没有缺省初始化，则编译报错。





#### placement new





`placement new`广义上包括四种使用情形：







  * 直接给出要构建的对象的内存位置。


  * 不抛出异常，如果内存分配失败返回空指针。


  * 定制的、带其他参数的内存分配器。


  * 用于调试目的的，在构造函数调用失败时。





狭义上的`placement new`是指第一种情形，用来在某个指定的内存地址构建对象。这种形式的`new`运算符会调用`operator new(size_t, OtherType)`函数来获取内存。这里的`OtherType`要和`new`括号里的参数的类型兼容。用法是：




    
    <code>new (expression-list) new-type-id (optional-initializer-expression-list);</code>





使用这种`placement new`，原因之一是程序不能在一块内存上自行调用其构造函数，必须由编译器系统生成的代码调用构造函数。原因之二是可能需要把对象放在特定硬件的内存地址上，或者放在多处理器内核的共享的内存地址上。  

释放这种对象时，不能调用`placement delete`，应直接调用其析构函数，如`pObj->~ClassType();`，然后再自行释放内存。





#### 保证不抛出异常的new运算符表达式





当内存分配失败时，`new`运算符的标准行为是抛出`std::bad_alloc`异常。也可以让`new`运算符在内存分配失败时不抛出异常而是返回空指针：




    
    <code>new (nothrow) Type(optional-initializer-expression-list);
    new (nothrow) Type[size];</code>





`nothrow`是`std::nothrow_t`的一个实例。  

最后，使用`new`和`delete`时，应遵守以下规则：







  * 不要使用`delete`来释放不是`new`分配的内存。


  * 不要使用`delete`释放同一个内存块两次。


  * 如果使用`new []`为数组分配内存，则应使用`delete []`来释放。


  * 如果使用`new []`为一个实体分配内存，则应使用`delete`（没有方括号）来释放。


  * 对空值指针应用`delete`是安全的。





### 自动存储、静态存储和动态存储





根据用于分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（也叫自由存储空间或堆）。在存在时间的长短方面，以这3种方式分配的数据对象各不相同：







  * 自动存储：在函数内部定义的常规变量使用自动存储空间，被称为自动变量，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。自动变量是一个局部变量，其作用域为包含它的代码块。


  * 静态存储：静态存储是整个程序执行期间都存在的存储方式。使变量称为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字`static`。自动存储和静态存储的关键是：这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也可能只是在特定函数被执行时存在（自动变量）。


  * 动态存储：`new`和`delete`操作符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，在C++中被称为自由存储空间。内存池同用于静态变量和自动变量的内存是分开的。`new`和`delete`允许在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期就不完全受到程序或函数的生存时间的限制了。与使用常规变量相比，使用`new`和`delete`使程序员对程序如何使用内存有更大的控制权。





**注意：**如果使用`new`操作符在自由存储空间（或堆）上创建变量后，没有调用`delete`，则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄漏。被泄露的内存将在程序的整个生命周期内都不可使用；这些内存被分配出去，但无法回收。极端情况下，内存泄漏可能会非常严重，以致应用可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。另外，这种泄漏还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致它们也相应崩溃。  

**指针是功能最强大的C++工具之一，但也最危险，因为它们允许执行对计算机不友好的操作，如使用未经初始化的指针来访问内存或者试图释放同一个内存块两次。**



