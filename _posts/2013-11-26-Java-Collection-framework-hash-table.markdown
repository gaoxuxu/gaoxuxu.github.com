---
author: gavin
comments: true
date: 2013-11-26 22:33:25
layout: post
title: Java集合框架——散列表
categories:
- 算法
- Java
---

##概念

散列表（Hash table）是一种可以根据关键字直接访问内存存储位置的数据结构，具体做法是，通过散列函数将关键字映射到一个存储位置:

* 若关键字为`k`，则其值存放在`f(k)`的存储位置上。因此，不需要比较便可以直接取得记录。对应关系`f`被称为散列函数。
* 不同的关键字可能有同一个散列地址，即对`k1!=k2`，有`f(k1)=f(k2)`，这种现象就是碰撞。

###常用的构造散列函数的方法

1. 直接寻址法：取关键字的某个线性值为散列地址。即`hash(k)=a*k + b`，其中`a`和`b`为常数。
2. 数字分析法：假设关键字是以`r`为基的数，并且散列表中可能出现的关键字是事先知道的，则可取关键字的若干数位组成散列地址。
3. 平方取中法：取关键字平方后的中间几位为散列地址。通常在选定散列函数时不一定知道关键字的全部情况，取其中的几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的散列地址也是随机的。取的位数由表决定。
4. 折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。
5. 随机数法：即`hash(k)=random(k)`，`random(k)`的取值范围为`0`到`m-1`，`m`为表长。
6. 除留余数法：取关键字被某个不大于散列表表长`m`的数`p`除后所得的余数为散列地址。即`hash(k)=k mod p, p<=m`。不仅可以对关键字直接取模，也可以在折叠法、平方取中法等运算后取模。对`p`的选择很重要，一般取素数或`m`，若`p`选择不好，容易产生碰撞。

###处理碰撞

实际中不发生碰撞的可能性非常小，所以通常要对碰撞进行处理。常用的方法有以下几种：

* 开放寻址法：$hash _i=(hash(key)+d _i) \mod m,i=1,2\dots k(k\le m-1)$，其中$hash(key)$为散列函数，$m$为散列表长，$d _i$为增量序列，$i$为已发生碰撞的次数。针对增量序列不同的取法一般可分为线性探测、平方探测以及伪随机探测等。
* 单独链表法：将散列到同一个位置的所有元素保存在一个链表中。实现时，一种策略是散列表同一位置的所有碰撞结果都是用栈存放的，新元素被插入到表的前端还是后端完全取决于怎样方便。
* 双散列：如果散列函数$hash(key)$出现冲突，则使用$hash _2(key)$求取散列地址，探测序列为$hash(key),hash(key)+hash _2(key),\cdots,hash(key)+i\cdot hash _2(key)$。
* 再散列：$hash _i=hash _i(key),i=1,2\dots k$。$hash _i$是一个散列函数的集合。即上次散列计算发生碰撞时，利用该次碰撞的散列函数地址产生新的散列函数地址，直到碰撞不再发生。
* 建立一个公共溢出区。

##Java中的HashMap

* `HashMap`处理碰撞使用的是链表法，参考`HashMap$Entry`类。
* `HashMap`类中的许多代码设计得很巧妙。

> Written with [StackEdit](https://stackedit.io/).
